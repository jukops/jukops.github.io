---
layout: post
title:  "Web Server 동작 비교"
date:   2019-09-11 00:23:00
author: Juhyeok Bae
categories: web
---
# 들어가며
웹서버는 보통 HTML이나 사진, 폰트 등의 정적인 리소스를 client에게 제공 하거나, tomcat 같은 WAS 서버 앞단에 위치하여 request를 WAS 쪽에 포워딩 해주는 역할을 한다. 포워딩 시 request에 헤더를 붙히기도 하고, URI를 구분하여 특정 서버에 분기 시키기도 하며 HTTPS인 경우 http termination 한 후 HTTP로 WAS에게 request를 넘기기도 한다. 뿐만 아니라 인증이나 압축 등의 많은 기능을 처리 하기도 한다.
이번 포스트에서는 가장 많이 사용되는 웹서버(웹프록시) 3개의 동작 방식을 알아 보고자 한다.

# Apache
- 소개
  Apache는 전세계 대표 웹서버이며, 현재 가장 많은 점유율을 가지고 있다. 나온지 오래 되었기 때문에 많은 사용 사례와 커뮤니티에서 개발된 많은 모듈(플러그인)을 가지고 있어 비교적 쉽게 사용이 가능하다.

- 동작방식
  아파치는 기본적으로 MPM(multi-processing module)로 동작한다. 처리하는 종류로는 프로세스 방식인 prefork와 쓰레드 방식인 worker, 비동기 처리 방식인 event가 있다.

  - prefork: 하나의 client 요청에 대해 하나의 프로세스가 할당되어 처리 하는 방식이다. 프로세스가 메모리 영역 까지 같이 복제되며, 프로세스 하나당 쓰레드가 하나 연결 된다. 프로세스가 복제 되어 독립적으로 존재 함으로 프로세스간 메모리 공유가 불가 하다. 요청당 프로세스가 하나가 붙어 독립적으로 실행 되기 때문에 때문에 비교적 안정적이라는 장점이 있다. 하지만 모든 요청에 대해 프로세스를 할당 하기 때문에 그만큼 메모리를 많이 소비하게 된다. 최대 프로세스는 1024개 까지 사용 가능하다.
  - worker: 하나의 client 요청에 대해 하나의 쓰레드가 할당되어 처리 하는 방식이다. prefork 방식이 프로세스 처리 였다면, worker는 쓰레드 처리라고 생각 하면 된다. 하나의 요청에 대해 프로세스가 붙는 것이 아니라 쓰레드가 생성 되어 처리 된다. 쓰레드 끼리는 메모리를 공유 하게 되기 때문에 메모리 소비가 prefork 보다 적다는 장점이 있다. 서버가 처리하는 request가 많다면 보통 prefork 보다는 worker를 쓰는쪽이 효율적이다.
  - event: apache와 nginx의 큰 차이점 이라고 하면 동기/비동기 처리 방식이었다. apache의 prefork와 worker의 경우 요청당 프로세스(쓰레드)가 하나씩 할당 되고 처리가 완료 되어야 해당 프로세스가 종료되는 동기 방식을 제공해 왔다. 반면 nginx의 경우 비동기 방식으로 동작 했는데, 평균적으로 apache 보다 높은 성능을 보여 주었다. apache에서도 2.4 버전 부터 event 방식을 지원하기 시작 했으며, nginx의 event 방식과 마찬가지 요청에 대해 비동기로 처리를 하는 방식이다. 더 작은 쓰레드로 더 많은 요청을 처리 가능하다.

# Nginx
- 소개  
  전 세계에서 apache 다음으로 인기가 많은 웹서버 이며, 점유율은 계속해서 상승세에 있다. 요청에 대해 동기 처리가 아닌 비동기 처리인 event-driven을 사용해 apache 보다 성능이 우수 하다는 평가를 받아 급 부상 하였다.

- 동작 방식  
  nginx는 기본적으로 비동기로 동작한다. 과거 동기 방식을 살펴 보면 아래와 같은 문제가 있었다.
  - 문제 1  
    1) client에서 하나의 요청이 들어옴.  
    2) 웹서버 에서는 쓰레드 하나를 생성 하여 할당.  
    3) 요청이 많아지는것은 곧 쓰레드가 많아짐을 뜻하며, 시스템의 메모리 사용량이 늘어남을 의미.  
       그리고 요청이 웹서버가 아닌 다른 이유로 오래 걸리더라도 할당된 프로세스는 계속해서 대기 상태.  
  - 문제 2  
    1) tcp hand-shake를 줄여 네트워크 성능 향상을 하고자 keep-alive를 도입.  
    2) keep-alive 사용시 한 클라이언트에 대해 한 쓰레드가 매핑 되며, 동작 방식상 일정시간 동안 쓰레드가 유지됨.  
    3) 웹서버에 많은 유저가 몰리면 그 만큼 쓰레드가 유지 됨으로, MaxClient 값 까지 도달하는 경우가 발생.  

  이런 경우에 효율성을 얻고자 nginx는 event-driven 방식을 사용한다. 요청이 오면 해당 요청을 쓰레드 마다 할당 하는것이 아니라 해당 요청이 어떤 일을 해야 하는지만 알려주고 다른 요청을 처리한다. 이로써 요청 마다 쓰레드가 생기지 않기 때문에 과도한 쓰레드 갯수에 의한 메모리 소모가 발생 하지 않는다. 그리고 keep-alive 사용시 많은 유저가 몰리면 쓰레드 갯수 때문에 최대값까지 도달 하는 문제도 쓰레드 갯수가 현저하게 줄어듬에 따라 해당 문제도 사라지게 된다.

# HAProxy
- 소개  
  HAProxy는 S/W 로드밸런서 이다. 앞전에 소개한 apache와 nginx의 경우 웹서버의 기능을 가지고 있어 정적 파일 호스팅을 하는 역할을 지니지만, HAProxy의 경우 이런 웹서버의 기능은 하지 않고 프록시의 기능만 가지고 있다. 비싼 L4 switch를 살 필요가 없기 때문에 비용적 이득을 얻을 수 있다.

- 동작방식  
  HAProxy도 nginx와 마찬가지 event-driven 방식을 가진다. 싱글 프로세스로 동작하며 비동기로 요청을 처리하여 효율성을 얻는다. context switch를 줄이며 메모리 사용량을 줄인다. HAProxy 공식 홈페이지에 따르면 a millisecond 당 수백개의 작업을 처리 할 수 있으며, 메모리 사용량은 세션당 kilobyte 수준이라고 한다.  
  Proxy 서버의 경우 뒷단에 있는 서버에 request를 포워딩 하는것이 목적이다. 그렇기 때문에 헬스체크를 하여 살아있는 노드에만 요청을 보내는것이 중요하다. HAProxy의 장점으로는 API 레벨로 헬스 체크를 할 수 있다. 특정 API를 호출 하여 200 code를 받은 경우 health라고 판단할 수 있는 것이다. 비슷한 nginx의 경우 단순체크는 가능 하지만 API 레벨로 체크를 하려면 유료버전을 사용 하여야 한다.
